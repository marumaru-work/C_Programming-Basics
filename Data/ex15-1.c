#include <stdio.h> //コレを書かないとprintf関数やscanf関数が使えない！
#define ELEMENT 5 //マクロ定数 （マクロの名前は必ず大文字！→小文字が1文字でも入るとコンパイルエラーになる）

int main (void)
{
    //int A[要素数（インデックス）] = {要素}; 要素数は普通に1,2,3...と数える！
    int A[ELEMENT] = {-2, 4, -6, 8, -10}; //小数点の要素を配列に格納した場合は、 int型 ではなく double型 にしないといけない！（普通の変数も同じ）
    int B[ELEMENT];

    for (int i = 0; i < ELEMENT; i++) // ビット反転（符号反転） 配列の要素を参照する場合、基本的に0から数える！
    {
        B[i] = -A[i]; //B[i番目] = -A[i番目] 配列Bのi番目の空箱に配列Aのi番目の箱を格納する。変数や配列変数名の前に-をつけると符号が逆転する。
    }

    for (int i = 1; i <= 2; i++) // 1回目のループで配列Aを、2回目のループで配列Bを出力する。
    {
        for (int j = 0; j < ELEMENT; j++) 
        {
            if (i == 1) // 1回目（1行目）
            {
                if (j == 0) //①最初に出力
                {
                    printf("int A[5] = { %d,", A[j]); // int A[5] = { -2,
                }
                else if (j == ELEMENT - 1) //⑤最後に出力
                {
                    printf(" %d}\n", A[j]); // int A[5] = { -2, 4, -6, 8, -10}（改行）
                }
                else //②〜④最初または最後ではない場合
                {
                    printf(" %d,", A[j]); // int A[5] = { -2, 4, -6, 8,
                }
            }
            else // 2回目（２行目）
            {
                if (j == 0) //①最初に出力
                {
                    printf("int B[5] = { %d,", B[j]);
                }
                else if (j == ELEMENT - 1) //⑤最後に出力
                {
                    printf(" %d}\n", B[j]); // int A[5] = { -2, 4, -6, 8, -10}
                }
                else //②〜④最初または最後ではない場合
                {
                    printf(" %d,", B[j]);
                }
            }
        }
    }
    return (0);
}

/*実行結果
int A[5] = { -2, 4, -6, 8, -10}
int B[5] = { 2, -4, 6, -8, 10}
*/